# JavaScript BASIS

> 数值

* JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）

* `Number.MAX_VALUE` - JS可表示的最大数 `- 1.7976931348623157e+308`

  ```js
    Number.MAX_VALUE + 100 === Number.MAX_VALUE // true
  ```

* `Number.MIN_VALUE` - JS可表示的最接近0的正数 `- 5e-324`

  ```js
    5E-325    //  0
    -5E-325   // -0
  ```

* `+0(0)` 与` -0`
  * 绝大部分情况下，两者没有区别

```js
  1 / +0 //  Infinity // > 0
  1 / -0 // -Infinity // < 0
```

> 变量提升

* 函数及变量的声明都将被提升到函数的最顶部
* 变量可以在使用后声明，也就是变量可以先使用再声明
* 初始化不会提升

> `Object.create()` - Object.create(proto[, propertiesObject])`

* 创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__
`
> 严格模式(`use strict`) [`ES5`]

*

> 函数

* 当函数没有被自身的对象调用时 this 的值就会变成全局对象
* 随着函数使用场合的不同，this 的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象
* 作为一个函数调用
  * 不属于任何对象,js中默认是全局对象
* 作为对象的方法调用
  * 函数作为对象方法调用，会使得 this 的值成为对象本身
* 使用构造函数调用函数
  * 构造函数中 this 关键字没有任何的值。this 的值在函数调用实例化对象(new object)时创建

> `call()`、`apply()`、`bind()`
  * 都是用来重定义 this 这个对象的
  * `bind` 返回的是一个新的函数，你必须调用它才会被执行
  * 三个函数的第一个参数都是 this 的指向对象
  * `call` 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔
  * `apply` 的所有参数都必须放在一个数组里面传进去
  * `bind` 除了返回是函数以外，它 的参数和 call 一样

> JavaScript 闭包

* 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境
* 在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收
* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包,在退出函数之前，将不使用的局部变量全部删除
