# ES6

## let 和 const 命令

* 不存在变量提升/暂时性死区
* 不允许重复声明
* 块级作用域
  * 允许在块级作用域之中声明函数
  * 函数声明还会提升到所在的块级作用域的头部

>ES6 声明变量的六种方法

* ES5 只有两种声明变量的方法：var命令和function命令
* ES6 有 6 种声明变量的方法：另外两中 import 和 class

> 顶层对象

* var命令和function命令声明的全局变量，依旧是顶层对象的属性
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性

## 变量的解构赋值

> 数组的解构

```js
let [a, b, c] = [1, 2, 3];
```

* 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
* 解构赋值允许指定默认值
  * 只有当一个数组成员严格等于undefined，默认值才会生效（null 也不行）
  * 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值

  ```js
    function f() {
      console.log('aaa');
    }
    let [x = f()] = [1];
  ```

  * let [x = y, y = 1] = [];     // ReferenceError: y is not defined
    * 逗号运算符，从左到右一次执行，执行上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明

> 对象的解构

```js
  let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
  let { foo: fo, bar: b } = { foo: 'aaa', bar: 'bbb' };
  // fo 'aaa', b 'bbb'
```

* 区别：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值

> 相同点

* 可以用于嵌套结构
* 默认值生效的条件是，对象的属性值严格等于undefined

> 注意点

* 结构对象时，不能将“{”至于句首，避免 JavaScript 将其解释为代码块
* 解构赋值允许等号左边的模式之中，不放置任何变量名
  * 虽然可能没有意义，但语法是合法的
* 字符串的解构赋值

  ```js
    const [a, b, c, d, e] = 'hello';
    a // "h"
    // length 是字符串的对象的 length 属性，len 是变量名
    let {length : len} = 'hello';
    len // 5
  ```

  * 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象

    ```js
      let {toString: s} = 123;
      s === Number.prototype.toString // true
    ```

    * 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象
    * 由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
  * 函数参数支持解构

> 圆括号问题

* 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号

> 任何部署了 Iterator 接口的对象，都可以用for...of循环遍历

## 字符串的扩展

> 字符的 Unicode 表示法

* \uxxxx (范围：\u0000~\uFFFF)
* 将码点放入大括号

```js
  "\uD842\uDFB7"
  "\u{20BB7}"
  // "𠮷"

  "\u{41}\u{42}\u{43}"
  // "ABC"
```

> 字符串的遍历器接口

* for...of 能识别可大于0xFFFF的码点

> 直接输入 U+2028 和 U+2029

*
> JSON.stringify() 的改造

* 可能返回0xD800到0xDFFF之间的单个码点
* 如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串

> 模板字符串

* 增强版的字符串，用反引号（`）标识
* 可以用来定义多行字符串，或者在字符串中嵌入变量或函数，`${}`

> 标签模板

* 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数
* 变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推

> 模板字符串的限制

* 模板字符串默认会将字符串转义，导致无法嵌入其他语言

## 正则的扩展

## 数值的扩展

JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）

> 二进制和八进制表示法

* 0b（或0B）和0o

> Number.isFinite(), Number.isNaN()

* Number.isFinite() - 检查一个数值是否为有限的（finite），即不是Infinity
* 用来检查一个值是否为NaN

> Number.parseInt(), Number.parseFloat()

* 全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变
* 字符串转 int 或者 float

> Number.isInteger()

* 判断一个数值是否为整数
* 数值的精度超过限度，可能会误判

> Number.EPSILON - 表示 1 与大于 1 的最小浮点数之间的差 - 2.220446049250313e-16

```js
  Number.EPSILON === Math.pow(2, -52)
  // true
```

> 安全整数和 Number.isSafeInteger()

* 准确表示的整数范围: Number.MAX_SAFE_INTEGER / Number.MIN_SAFE_INTEGER
* -2^53 到 2^53 - 9007199254740992 到 -9007199254740992
* Number.isSafeInteger() - 判断一个整数是否落在这个范围之内
* 安全范围之外的计算，可能是不准确的，判断计算结果是否准确，参与的数的需要是安全的

```js
9007199254740995 - 10  // 9007199254740986
```

> Math 对象的扩展

* ES6 在 Math 对象上新增了 17 个与数学相关的方法
  * Math.trunc - 用于去除一个数的小数部分，返回整数部分
  * Math.sign - 符号函数(+0, -0, +1, -1, NaN)

> 指数运算符  `**`

* 一个特点是右结合，而不是常见的左结合

```js
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2 // 512
```

> BigInt 数据类型 [`ES2020`]

* 表示整数，没有位数的限制，任何位数的整数都可以精确表示
* BigInt 与普通整数是两种值，它们之间并不相等
* typeof运算符对于 BigInt 类型的数据返回bigint
* 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突

## 函数的扩展

> 函数参数的默认值

* 使用参数默认值时，函数不能有同名参数

```js
// 写法一  默认值是空对象，但是设置了对象解构赋值的默认值
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}
// 写法二  默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]
```

* 如果非尾部的参数设置默认值，实际上这个参数是没法省略的，除非显式输入undefined
* 函数的 length 属性 - 返回没有指定默认值的参数个数

  ```js
    (function (a, b, c = 5) {}).length // 2
  ```

* 存在作用域


rest 参数
严格模式
name 属性
箭头函数
尾调用优化
函数参数的尾逗号
Function.prototype.toString()
catch 命令的参数省略
